use std::{
    fmt::{Debug, Display},
    ops::Deref,
};

pub const MAX_SENSE_BUFFER_LENGTH: usize = 252;

#[derive(Clone, Debug)]
pub enum SenseData {
    None,
    Fixed(FixedSenseData),
    Descriptor(DescriptorSenseData),
    Raw(Vec<u8>),
}

impl SenseData {
    pub fn parse(raw: &[u8; MAX_SENSE_BUFFER_LENGTH], sense_length: usize) -> Self {
        let response_code = raw[0] & 0b01111111;
        match response_code {
            0 => Self::None,
            0x70 | 0x71 => {
                let sense_key = SenseKey::from(raw[2] & 0b00001111);
                let additional_sense_length = raw[7];
                if additional_sense_length as usize + 8 != sense_length {
                    return Self::Raw(Vec::from(&raw[..sense_length]));
                }

                let sense = FixedSenseData {
                    is_valid: (raw[0] & 0b10000000) != 0,
                    response_code: ErrorType::from(response_code),
                    is_filemark: (raw[2] & 0b10000000) != 0,
                    is_end_of_medium: (raw[2] & 0b01000000) != 0,
                    is_incorrect_length_indicator: (raw[2] & 0b00100000) != 0,
                    sense_key,
                    information: raw[3..=6].try_into().unwrap(),
                    command_specific_information: raw[8..=11].try_into().unwrap(),
                    additional_sense_code: AdditionalSenseCode::from((raw[12], raw[13])),
                    field_replaceable_unit_code: raw[14],
                    is_sense_key_specific_valid: (raw[15] & 0b10000000) != 0,
                    sense_key_specific: SenseKeySpecific::parse(&raw[15..=17], sense_key),
                    additional_sense_bytes: Vec::from(&raw[18..sense_length]),
                };

                Self::Fixed(sense)
            }
            0x72 | 0x73 => {
                let mut descriptor_index = 8usize;
                if descriptor_index + raw[7] as usize != sense_length {
                    return Self::Raw(Vec::from(&raw[..sense_length]));
                }

                let sense_key = SenseKey::from(raw[1] & 0b00001111);

                let mut descriptors = vec![];
                while descriptor_index < sense_length {
                    let descriptor = Descriptor::parse(&raw[descriptor_index..], sense_key);
                    descriptors.push(descriptor);
                    descriptor_index += DESCRIPTOR_HEADER_LENGTH + raw[1] as usize;
                }

                let sense = DescriptorSenseData {
                    response_code: ErrorType::from(response_code),
                    sense_key,
                    additional_sense_code: AdditionalSenseCode::from((raw[2], raw[3])),
                    descriptors,
                };

                Self::Descriptor(sense)
            }
            _ => Self::Raw(Vec::from(&raw[..sense_length])),
        }
    }
}

#[derive(Clone, Debug)]
pub struct FixedSenseData {
    pub is_valid: bool,
    pub response_code: ErrorType,
    pub is_filemark: bool,
    pub is_end_of_medium: bool,
    pub is_incorrect_length_indicator: bool,
    pub sense_key: SenseKey,
    pub information: [u8; 4],
    pub command_specific_information: [u8; 4],
    pub additional_sense_code: AdditionalSenseCode,
    pub field_replaceable_unit_code: u8,
    pub is_sense_key_specific_valid: bool,
    pub sense_key_specific: SenseKeySpecific,
    pub additional_sense_bytes: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct DescriptorSenseData {
    pub response_code: ErrorType,
    pub sense_key: SenseKey,
    pub additional_sense_code: AdditionalSenseCode,
    pub descriptors: Vec<Descriptor>,
}

#[derive(Clone, Debug)]
pub enum ErrorType {
    Current,
    Deferred,
    Unknown(u8),
}

impl From<u8> for ErrorType {
    fn from(value: u8) -> Self {
        match value {
            0x70 | 0x72 => Self::Current,
            0x71 | 0x73 => Self::Deferred,
            _ => Self::Unknown(value),
        }
    }
}

#[repr(u8)]
#[derive(Clone, Copy, Debug)]
pub enum SenseKey {
    NoSense,
    RecoveredError,
    NotReady,
    MediumError,
    HardwareError,
    IllegalRequest,
    UnitAttention,
    DataProtect,
    BlankCheck,
    VendorSpecific,
    CopyAborted,
    AbortedCommand,
    Reserved,
    VolumeOverflow,
    Miscompare,
    Completed,
}

impl From<u8> for SenseKey {
    fn from(value: u8) -> Self {
        match value {
            0x0 => Self::NoSense,
            0x1 => Self::RecoveredError,
            0x2 => Self::NotReady,
            0x3 => Self::MediumError,
            0x4 => Self::HardwareError,
            0x5 => Self::IllegalRequest,
            0x6 => Self::UnitAttention,
            0x7 => Self::DataProtect,
            0x8 => Self::BlankCheck,
            0x9 => Self::VendorSpecific,
            0xA => Self::CopyAborted,
            0xB => Self::AbortedCommand,
            0xC => Self::Reserved,
            0xD => Self::VolumeOverflow,
            0xE => Self::Miscompare,
            0xF => Self::Completed,
            _ => panic!("Not reachable"),
        }
    }
}

#[derive(Clone, Debug)]
pub enum Descriptor {
    Information {
        is_valid: bool,
        information: [u8; 8],
    },
    CommandSpecificInformation {
        command_specific_information: [u8; 8],
    },
    SenseKeySpecific {
        is_sense_key_specific_valid: bool,
        sense_key_specific: SenseKeySpecific,
    },
    FieldReplaceableUnit {
        field_replaceable_unit_code: u8,
    },
    StreamCommands(Vec<u8>),
    BlockCommands(Vec<u8>),
    OsdObjectIdentification(Vec<u8>),
    OsdResponseIntegrityCheckValue(Vec<u8>),
    OsdAttributeIdentification(Vec<u8>),
    AtaReturn(Vec<u8>),
    AnotherProgressIndication {
        sense_key: SenseKey,
        additional_sense_code: AdditionalSenseCode,
        progress_indication: u16,
    },
    Unknown(Vec<u8>),
}

impl Descriptor {
    fn parse(raw: &[u8], sense_key: SenseKey) -> Self {
        let additional_length = raw[1] as usize;
        let raw = &raw[..DESCRIPTOR_HEADER_LENGTH + additional_length];
        match raw[0] {
            0x00 => {
                if additional_length != 0x0A {
                    return Self::Unknown(Vec::from(raw));
                }

                Self::Information {
                    is_valid: (raw[2] & 0b10000000) != 0,
                    information: raw[4..=11].try_into().unwrap(),
                }
            }
            0x01 => {
                if additional_length != 0x0A {
                    return Self::Unknown(Vec::from(raw));
                }

                Self::CommandSpecificInformation {
                    command_specific_information: raw[4..=11].try_into().unwrap(),
                }
            }
            0x02 => {
                if additional_length != 0x06 {
                    return Self::Unknown(Vec::from(raw));
                }

                Self::SenseKeySpecific {
                    is_sense_key_specific_valid: (raw[4] & 0b10000000) != 0,
                    sense_key_specific: SenseKeySpecific::parse(&raw[4..=6], sense_key),
                }
            }
            0x03 => {
                if additional_length != 0x02 {
                    return Self::Unknown(Vec::from(raw));
                }

                Self::FieldReplaceableUnit {
                    field_replaceable_unit_code: raw[3],
                }
            }
            0x04 => Self::StreamCommands(Vec::from(raw)),
            0x05 => Self::BlockCommands(Vec::from(raw)),
            0x06 => Self::OsdObjectIdentification(Vec::from(raw)),
            0x07 => Self::OsdResponseIntegrityCheckValue(Vec::from(raw)),
            0x08 => Self::OsdAttributeIdentification(Vec::from(raw)),
            0x09 => Self::AtaReturn(Vec::from(raw)),
            0x0A => {
                if additional_length != 0x06 {
                    return Self::Unknown(Vec::from(raw));
                }

                Self::AnotherProgressIndication {
                    sense_key: SenseKey::from(raw[2]),
                    additional_sense_code: AdditionalSenseCode::from((raw[3], raw[4])),
                    progress_indication: u16::from_be_bytes(raw[6..=7].try_into().unwrap()),
                }
            }
            _ => Self::Unknown(Vec::from(raw)),
        }
    }
}

#[derive(Clone, Debug)]
pub enum SenseKeySpecific {
    IllegalRequest {
        is_command_data: bool,
        is_bit_pointer_valid: bool,
        bit_pointer: u8,
        field_pointer: u16,
    },
    HardwareError {
        actual_retry_count: u16,
    },
    NoSense {
        progress_indication: u16,
    },
    CopyAborted {
        is_segment_descriptor: bool,
        is_bit_pointer_valid: bool,
        bit_pointer: u8,
        field_pointer: u16,
    },
    UnitAttention {
        is_overflow: bool,
    },
    InvalidSenseKey,
}

impl SenseKeySpecific {
    fn parse(raw: &[u8], sense_key: SenseKey) -> Self {
        match sense_key {
            SenseKey::IllegalRequest => Self::IllegalRequest {
                is_command_data: (raw[0] & 0b01000000) != 0,
                is_bit_pointer_valid: (raw[0] & 0b00001000) != 0,
                bit_pointer: (raw[0] & 0b00000111),
                field_pointer: u16::from_be_bytes(raw[1..=2].try_into().unwrap()),
            },
            SenseKey::HardwareError | SenseKey::MediumError | SenseKey::RecoveredError => {
                Self::HardwareError {
                    actual_retry_count: u16::from_be_bytes(raw[1..=2].try_into().unwrap()),
                }
            }
            SenseKey::NoSense | SenseKey::NotReady => Self::NoSense {
                progress_indication: u16::from_be_bytes(raw[1..=2].try_into().unwrap()),
            },
            SenseKey::CopyAborted => Self::CopyAborted {
                is_segment_descriptor: (raw[0] & 0b00100000) != 0,
                is_bit_pointer_valid: (raw[0] & 0b00001000) != 0,
                bit_pointer: (raw[0] & 0b00000111),
                field_pointer: u16::from_be_bytes(raw[1..=2].try_into().unwrap()),
            },
            SenseKey::UnitAttention => Self::UnitAttention {
                is_overflow: (raw[0] & 0b00000001) != 0,
            },
            _ => Self::InvalidSenseKey,
        }
    }
}

#[repr(transparent)]
#[derive(Clone)]
pub struct AdditionalSenseCode(u16);

impl Deref for AdditionalSenseCode {
    type Target = u16;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Display for AdditionalSenseCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let description = match self.0 {
            0x0000 => String::from("NO ADDITIONAL SENSE INFORMATION"),
            0x0001 => String::from("FILEMARK DETECTED"),
            0x0002 => String::from("END-OF-PARTITION/MEDIUM DETECTED"),
            0x0003 => String::from("SETMARK DETECTED"),
            0x0004 => String::from("BEGINNING-OF-PARTITION/MEDIUM DETECTED"),
            0x0005 => String::from("END-OF-DATA DETECTED"),
            0x0006 => String::from("I/O PROCESS TERMINATED"),
            0x0007 => String::from("PROGRAMMABLE EARLY WARNING DETECTED"),
            0x0011 => String::from("AUDIO PLAY OPERATION IN PROGRESS"),
            0x0012 => String::from("AUDIO PLAY OPERATION PAUSED"),
            0x0013 => String::from("AUDIO PLAY OPERATION SUCCESSFULLY COMPLETED"),
            0x0014 => String::from("AUDIO PLAY OPERATION STOPPED DUE TO ERROR"),
            0x0015 => String::from("NO CURRENT AUDIO STATUS TO RETURN"),
            0x0016 => String::from("OPERATION IN PROGRESS"),
            0x0017 => String::from("CLEANING REQUESTED"),
            0x0018 => String::from("ERASE OPERATION IN PROGRESS"),
            0x0019 => String::from("LOCATE OPERATION IN PROGRESS"),
            0x001A => String::from("REWIND OPERATION IN PROGRESS"),
            0x001B => String::from("SET CAPACITY OPERATION IN PROGRESS"),
            0x001C => String::from("VERIFY OPERATION IN PROGRESS"),
            0x001D => String::from("ATA PASS THROUGH INFORMATION AVAILABLE"),
            0x001E => String::from("CONFLICTING SA CREATION REQUEST"),
            0x001F => String::from("LOGICAL UNIT TRANSITIONING TO ANOTHER POWER CONDITION"),
            0x0020 => String::from("EXTENDED COPY INFORMATION AVAILABLE"),
            0x0021 => String::from("ATOMIC COMMAND ABORTED DUE TO ACA"),
            0x0022 => String::from("DEFERRED MICROCODE IS PENDING"),
            0x0100 => String::from("NO INDEX/SECTOR SIGNAL"),
            0x0200 => String::from("NO SEEK COMPLETE"),
            0x0300 => String::from("PERIPHERAL DEVICE WRITE FAULT"),
            0x0301 => String::from("NO WRITE CURRENT"),
            0x0302 => String::from("EXCESSIVE WRITE ERRORS"),
            0x0400 => String::from("LOGICAL UNIT NOT READY, CAUSE NOT REPORTABLE"),
            0x0401 => String::from("LOGICAL UNIT IS IN PROCESS OF BECOMING READY"),
            0x0402 => String::from("LOGICAL UNIT NOT READY, INITIALIZING COMMAND REQUIRED"),
            0x0403 => String::from("LOGICAL UNIT NOT READY, MANUAL INTERVENTION REQUIRED"),
            0x0404 => String::from("LOGICAL UNIT NOT READY, FORMAT IN PROGRESS"),
            0x0405 => String::from("LOGICAL UNIT NOT READY, REBUILD IN PROGRESS"),
            0x0406 => String::from("LOGICAL UNIT NOT READY, RECALCULATION IN PROGRESS"),
            0x0407 => String::from("LOGICAL UNIT NOT READY, OPERATION IN PROGRESS"),
            0x0408 => String::from("LOGICAL UNIT NOT READY, LONG WRITE IN PROGRESS"),
            0x0409 => String::from("LOGICAL UNIT NOT READY, SELF-TEST IN PROGRESS"),
            0x040A => {
                String::from("LOGICAL UNIT NOT ACCESSIBLE, ASYMMETRIC ACCESS STATE TRANSITION")
            }
            0x040B => String::from("LOGICAL UNIT NOT ACCESSIBLE, TARGET PORT IN STANDBY STATE"),
            0x040C => String::from("LOGICAL UNIT NOT ACCESSIBLE, TARGET PORT IN UNAVAILABLE STATE"),
            0x040D => String::from("LOGICAL UNIT NOT READY, STRUCTURE CHECK REQUIRED"),
            0x040E => String::from("LOGICAL UNIT NOT READY, SECURITY SESSION IN PROGRESS"),
            0x0410 => String::from("LOGICAL UNIT NOT READY, AUXILIARY MEMORY NOT ACCESSIBLE"),
            0x0411 => String::from("LOGICAL UNIT NOT READY, NOTIFY (ENABLE SPINUP) REQUIRED"),
            0x0412 => String::from("LOGICAL UNIT NOT READY, OFFLINE"),
            0x0413 => String::from("LOGICAL UNIT NOT READY, SA CREATION IN PROGRESS"),
            0x0414 => String::from("LOGICAL UNIT NOT READY, SPACE ALLOCATION IN PROGRESS"),
            0x0415 => String::from("LOGICAL UNIT NOT READY, ROBOTICS DISABLED"),
            0x0416 => String::from("LOGICAL UNIT NOT READY, CONFIGURATION REQUIRED"),
            0x0417 => String::from("LOGICAL UNIT NOT READY, CALIBRATION REQUIRED"),
            0x0418 => String::from("LOGICAL UNIT NOT READY, A DOOR IS OPEN"),
            0x0419 => String::from("LOGICAL UNIT NOT READY, OPERATING IN SEQUENTIAL MODE"),
            0x041A => String::from("LOGICAL UNIT NOT READY, START STOP UNIT COMMAND IN PROGRESS"),
            0x041B => String::from("LOGICAL UNIT NOT READY, SANITIZE IN PROGRESS"),
            0x041C => String::from("LOGICAL UNIT NOT READY, ADDITIONAL POWER USE NOT YET GRANTED"),
            0x041D => String::from("LOGICAL UNIT NOT READY, CONFIGURATION IN PROGRESS"),
            0x041E => String::from("LOGICAL UNIT NOT READY, MICROCODE ACTIVATION REQUIRED"),
            0x041F => String::from("LOGICAL UNIT NOT READY, MICROCODE DOWNLOAD REQUIRED"),
            0x0420 => String::from("LOGICAL UNIT NOT READY, LOGICAL UNIT RESET REQUIRED"),
            0x0421 => String::from("LOGICAL UNIT NOT READY, HARD RESET REQUIRED"),
            0x0422 => String::from("LOGICAL UNIT NOT READY, POWER CYCLE REQUIRED"),
            0x0423 => String::from("LOGICAL UNIT NOT READY, AFFILIATION REQUIRED"),
            0x0424 => String::from("DEPOPULATION IN PROGRESS"),
            0x0425 => String::from("DEPOPULATION RESTORATION IN PROGRESS"),
            0x0500 => String::from("LOGICAL UNIT DOES NOT RESPOND TO SELECTION"),
            0x0600 => String::from("NO REFERENCE POSITION FOUND"),
            0x0700 => String::from("MULTIPLE PERIPHERAL DEVICES SELECTED"),
            0x0800 => String::from("LOGICAL UNIT COMMUNICATION FAILURE"),
            0x0801 => String::from("LOGICAL UNIT COMMUNICATION TIME-OUT"),
            0x0802 => String::from("LOGICAL UNIT COMMUNICATION PARITY ERROR"),
            0x0803 => String::from("LOGICAL UNIT COMMUNICATION CRC ERROR (ULTRA-DMA/32)"),
            0x0804 => String::from("UNREACHABLE COPY TARGET"),
            0x0900 => String::from("TRACK FOLLOWING ERROR"),
            0x0901 => String::from("TRACKING SERVO FAILURE"),
            0x0902 => String::from("FOCUS SERVO FAILURE"),
            0x0903 => String::from("SPINDLE SERVO FAILURE"),
            0x0904 => String::from("HEAD SELECT FAULT"),
            0x0905 => String::from("VIBRATION INDUCED TRACKING ERROR"),
            0x0A00 => String::from("ERROR LOG OVERFLOW"),
            0x0B00 => String::from("WARNING"),
            0x0B01 => String::from("WARNING - SPECIFIED TEMPERATURE EXCEEDED"),
            0x0B02 => String::from("WARNING - ENCLOSURE DEGRADED"),
            0x0B03 => String::from("WARNING - BACKGROUND SELF-TEST FAILED"),
            0x0B04 => String::from("WARNING - BACKGROUND PRE-SCAN DETECTED MEDIUM ERROR"),
            0x0B05 => String::from("WARNING - BACKGROUND MEDIUM SCAN DETECTED MEDIUM ERROR"),
            0x0B06 => String::from("WARNING - NON-VOLATILE CACHE NOW VOLATILE"),
            0x0B07 => String::from("WARNING - DEGRADED POWER TO NON-VOLATILE CACHE"),
            0x0B08 => String::from("WARNING - POWER LOSS EXPECTED"),
            0x0B09 => String::from("WARNING - DEVICE STATISTICS NOTIFICATION ACTIVE"),
            0x0B0A => String::from("WARNING - HIGH CRITICAL TEMPERATURE LIMIT EXCEEDED"),
            0x0B0B => String::from("WARNING - LOW CRITICAL TEMPERATURE LIMIT EXCEEDED"),
            0x0B0C => String::from("WARNING - HIGH OPERATING TEMPERATURE LIMIT EXCEEDED"),
            0x0B0D => String::from("WARNING - LOW OPERATING TEMPERATURE LIMIT EXCEEDED"),
            0x0B0E => String::from("WARNING - HIGH CRITICAL HUMIDITY LIMIT EXCEEDED"),
            0x0B0F => String::from("WARNING - LOW CRITICAL HUMIDITY LIMIT EXCEEDED"),
            0x0B10 => String::from("WARNING - HIGH OPERATING HUMIDITY LIMIT EXCEEDED"),
            0x0B11 => String::from("WARNING - LOW OPERATING HUMIDITY LIMIT EXCEEDED"),
            0x0B12 => String::from("WARNING - MICROCODE SECURITY AT RISK"),
            0x0B13 => String::from("WARNING - MICROCODE DIGITAL SIGNATURE VALIDATION FAILURE"),
            0x0B14 => String::from("WARNING - PHYSICAL ELEMENT STATUS CHANGE"),
            0x0C00 => String::from("WRITE ERROR"),
            0x0C01 => String::from("WRITE ERROR - RECOVERED WITH AUTO REALLOCATION"),
            0x0C02 => String::from("WRITE ERROR - AUTO REALLOCATION FAILED"),
            0x0C03 => String::from("WRITE ERROR - RECOMMEND REASSIGNMENT"),
            0x0C04 => String::from("COMPRESSION CHECK MISCOMPARE ERROR"),
            0x0C05 => String::from("DATA EXPANSION OCCURRED DURING COMPRESSION"),
            0x0C06 => String::from("BLOCK NOT COMPRESSIBLE"),
            0x0C07 => String::from("WRITE ERROR - RECOVERY NEEDED"),
            0x0C08 => String::from("WRITE ERROR - RECOVERY FAILED"),
            0x0C09 => String::from("WRITE ERROR - LOSS OF STREAMING"),
            0x0C0A => String::from("WRITE ERROR - PADDING BLOCKS ADDED"),
            0x0C0B => String::from("AUXILIARY MEMORY WRITE ERROR"),
            0x0C0C => String::from("WRITE ERROR - UNEXPECTED UNSOLICITED DATA"),
            0x0C0D => String::from("WRITE ERROR - NOT ENOUGH UNSOLICITED DATA"),
            0x0C0E => String::from("MULTIPLE WRITE ERRORS"),
            0x0C0F => String::from("DEFECTS IN ERROR WINDOW"),
            0x0C10 => String::from("INCOMPLETE MULTIPLE ATOMIC WRITE OPERATIONS"),
            0x0C11 => String::from("WRITE ERROR - RECOVERY SCAN NEEDED"),
            0x0C12 => String::from("WRITE ERROR - INSUFFICIENT ZONE RESOURCES"),
            0x0D00 => String::from("ERROR DETECTED BY THIRD PARTY TEMPORARY INITIATOR"),
            0x0D01 => String::from("THIRD PARTY DEVICE FAILURE"),
            0x0D02 => String::from("COPY TARGET DEVICE NOT REACHABLE"),
            0x0D03 => String::from("INCORRECT COPY TARGET DEVICE TYPE"),
            0x0D04 => String::from("COPY TARGET DEVICE DATA UNDERRUN"),
            0x0D05 => String::from("COPY TARGET DEVICE DATA OVERRUN"),
            0x0E00 => String::from("INVALID INFORMATION UNIT"),
            0x0E01 => String::from("INFORMATION UNIT TOO SHORT"),
            0x0E02 => String::from("INFORMATION UNIT TOO LONG"),
            0x0E03 => String::from("INVALID FIELD IN COMMAND INFORMATION UNIT"),
            0x1000 => String::from("ID CRC OR ECC ERROR"),
            0x1001 => String::from("LOGICAL BLOCK GUARD CHECK FAILED"),
            0x1002 => String::from("LOGICAL BLOCK APPLICATION TAG CHECK FAILED"),
            0x1003 => String::from("LOGICAL BLOCK REFERENCE TAG CHECK FAILED"),
            0x1004 => String::from("LOGICAL BLOCK PROTECTION ERROR ON RECOVER BUFFERED DATA"),
            0x1005 => String::from("LOGICAL BLOCK PROTECTION METHOD ERROR"),
            0x1100 => String::from("UNRECOVERED READ ERROR"),
            0x1101 => String::from("READ RETRIES EXHAUSTED"),
            0x1102 => String::from("ERROR TOO LONG TO CORRECT"),
            0x1103 => String::from("MULTIPLE READ ERRORS"),
            0x1104 => String::from("UNRECOVERED READ ERROR - AUTO REALLOCATE FAILED"),
            0x1105 => String::from("L-EC UNCORRECTABLE ERROR"),
            0x1106 => String::from("CIRC UNRECOVERED ERROR"),
            0x1107 => String::from("DATA RE-SYNCHRONIZATION ERROR"),
            0x1108 => String::from("INCOMPLETE BLOCK READ"),
            0x1109 => String::from("NO GAP FOUND"),
            0x110A => String::from("MISCORRECTED ERROR"),
            0x110B => String::from("UNRECOVERED READ ERROR - RECOMMEND REASSIGNMENT"),
            0x110C => String::from("UNRECOVERED READ ERROR - RECOMMEND REWRITE THE DATA"),
            0x110D => String::from("DE-COMPRESSION CRC ERROR"),
            0x110E => String::from("CANNOT DECOMPRESS USING DECLARED ALGORITHM"),
            0x110F => String::from("ERROR READING UPC/EAN NUMBER"),
            0x1110 => String::from("ERROR READING ISRC NUMBER"),
            0x1111 => String::from("READ ERROR - LOSS OF STREAMING"),
            0x1112 => String::from("AUXILIARY MEMORY READ ERROR"),
            0x1113 => String::from("READ ERROR - FAILED RETRANSMISSION REQUEST"),
            0x1114 => String::from("READ ERROR - LBA MARKED BAD BY APPLICATION CLIENT"),
            0x1115 => String::from("WRITE AFTER SANITIZE REQUIRED"),
            0x1200 => String::from("ADDRESS MARK NOT FOUND FOR ID FIELD"),
            0x1300 => String::from("ADDRESS MARK NOT FOUND FOR DATA FIELD"),
            0x1400 => String::from("RECORDED ENTITY NOT FOUND"),
            0x1401 => String::from("RECORD NOT FOUND"),
            0x1402 => String::from("FILEMARK OR SETMARK NOT FOUND"),
            0x1403 => String::from("END-OF-DATA NOT FOUND"),
            0x1404 => String::from("BLOCK SEQUENCE ERROR"),
            0x1405 => String::from("RECORD NOT FOUND - RECOMMEND REASSIGNMENT"),
            0x1406 => String::from("RECORD NOT FOUND - DATA AUTO-REALLOCATED"),
            0x1407 => String::from("LOCATE OPERATION FAILURE"),
            0x1500 => String::from("RANDOM POSITIONING ERROR"),
            0x1501 => String::from("MECHANICAL POSITIONING ERROR"),
            0x1502 => String::from("POSITIONING ERROR DETECTED BY READ OF MEDIUM"),
            0x1600 => String::from("DATA SYNCHRONIZATION MARK ERROR"),
            0x1601 => String::from("DATA SYNC ERROR - DATA REWRITTEN"),
            0x1602 => String::from("DATA SYNC ERROR - RECOMMEND REWRITE"),
            0x1603 => String::from("DATA SYNC ERROR - DATA AUTO-REALLOCATED"),
            0x1604 => String::from("DATA SYNC ERROR - RECOMMEND REASSIGNMENT"),
            0x1700 => String::from("RECOVERED DATA WITH NO ERROR CORRECTION APPLIED"),
            0x1701 => String::from("RECOVERED DATA WITH RETRIES"),
            0x1702 => String::from("RECOVERED DATA WITH POSITIVE HEAD OFFSET"),
            0x1703 => String::from("RECOVERED DATA WITH NEGATIVE HEAD OFFSET"),
            0x1704 => String::from("RECOVERED DATA WITH RETRIES AND/OR CIRC APPLIED"),
            0x1705 => String::from("RECOVERED DATA USING PREVIOUS SECTOR ID"),
            0x1706 => String::from("RECOVERED DATA WITHOUT ECC - DATA AUTO-REALLOCATED"),
            0x1707 => String::from("RECOVERED DATA WITHOUT ECC - RECOMMEND REASSIGNMENT"),
            0x1708 => String::from("RECOVERED DATA WITHOUT ECC - RECOMMEND REWRITE"),
            0x1709 => String::from("RECOVERED DATA WITHOUT ECC - DATA REWRITTEN"),
            0x1800 => String::from("RECOVERED DATA WITH ERROR CORRECTION APPLIED"),
            0x1801 => String::from("RECOVERED DATA WITH ERROR CORR. & RETRIES APPLIED"),
            0x1802 => String::from("RECOVERED DATA - DATA AUTO-REALLOCATED"),
            0x1803 => String::from("RECOVERED DATA WITH CIRC"),
            0x1804 => String::from("RECOVERED DATA WITH L-EC"),
            0x1805 => String::from("RECOVERED DATA - RECOMMEND REASSIGNMENT"),
            0x1806 => String::from("RECOVERED DATA - RECOMMEND REWRITE"),
            0x1807 => String::from("RECOVERED DATA WITH ECC - DATA REWRITTEN"),
            0x1808 => String::from("RECOVERED DATA WITH LINKING"),
            0x1900 => String::from("DEFECT LIST ERROR"),
            0x1901 => String::from("DEFECT LIST NOT AVAILABLE"),
            0x1902 => String::from("DEFECT LIST ERROR IN PRIMARY LIST"),
            0x1903 => String::from("DEFECT LIST ERROR IN GROWN LIST"),
            0x1A00 => String::from("PARAMETER LIST LENGTH ERROR"),
            0x1B00 => String::from("SYNCHRONOUS DATA TRANSFER ERROR"),
            0x1C00 => String::from("DEFECT LIST NOT FOUND"),
            0x1C01 => String::from("PRIMARY DEFECT LIST NOT FOUND"),
            0x1C02 => String::from("GROWN DEFECT LIST NOT FOUND"),
            0x1D00 => String::from("MISCOMPARE DURING VERIFY OPERATION"),
            0x1D01 => String::from("MISCOMPARE VERIFY OF UNMAPPED LBA"),
            0x1E00 => String::from("RECOVERED ID WITH ECC CORRECTION"),
            0x1F00 => String::from("PARTIAL DEFECT LIST TRANSFER"),
            0x2000 => String::from("INVALID COMMAND OPERATION CODE"),
            0x2001 => String::from("ACCESS DENIED - INITIATOR PENDING-ENROLLED"),
            0x2002 => String::from("ACCESS DENIED - NO ACCESS RIGHTS"),
            0x2003 => String::from("ACCESS DENIED - INVALID MGMT ID KEY"),
            0x2004 => String::from("ILLEGAL COMMAND WHILE IN WRITE CAPABLE STATE"),
            0x2005 => String::from("Obsolete"),
            0x2006 => String::from("ILLEGAL COMMAND WHILE IN EXPLICIT ADDRESS MODE"),
            0x2007 => String::from("ILLEGAL COMMAND WHILE IN IMPLICIT ADDRESS MODE"),
            0x2008 => String::from("ACCESS DENIED - ENROLLMENT CONFLICT"),
            0x2009 => String::from("ACCESS DENIED - INVALID LU IDENTIFIER"),
            0x200A => String::from("ACCESS DENIED - INVALID PROXY TOKEN"),
            0x200B => String::from("ACCESS DENIED - ACL LUN CONFLICT"),
            0x200C => String::from("ILLEGAL COMMAND WHEN NOT IN APPEND-ONLY MODE"),
            0x200D => String::from("NOT AN ADMINISTRATIVE LOGICAL UNIT"),
            0x200E => String::from("NOT A SUBSIDIARY LOGICAL UNIT"),
            0x200F => String::from("NOT A CONGLOMERATE LOGICAL UNIT"),
            0x2100 => String::from("LOGICAL BLOCK ADDRESS OUT OF RANGE"),
            0x2101 => String::from("INVALID ELEMENT ADDRESS"),
            0x2102 => String::from("INVALID ADDRESS FOR WRITE"),
            0x2103 => String::from("INVALID WRITE CROSSING LAYER JUMP"),
            0x2104 => String::from("UNALIGNED WRITE COMMAND"),
            0x2105 => String::from("WRITE BOUNDARY VIOLATION"),
            0x2106 => String::from("ATTEMPT TO READ INVALID DATA"),
            0x2107 => String::from("READ BOUNDARY VIOLATION"),
            0x2108 => String::from("MISALIGNED WRITE COMMAND"),
            0x2109 => String::from("ATTEMPT TO ACCESS GAP ZONE"),
            0x2200 => String::from("ILLEGAL FUNCTION (USE 20 00, 24 00, OR 26 00)"),
            0x2300 => String::from("INVALID TOKEN OPERATION, CAUSE NOT REPORTABLE"),
            0x2301 => String::from("INVALID TOKEN OPERATION, UNSUPPORTED TOKEN TYPE"),
            0x2302 => String::from("INVALID TOKEN OPERATION, REMOTE TOKEN USAGE NOT SUPPORTED"),
            0x2303 => {
                String::from("INVALID TOKEN OPERATION, REMOTE ROD TOKEN CREATION NOT SUPPORTED")
            }
            0x2304 => String::from("INVALID TOKEN OPERATION, TOKEN UNKNOWN"),
            0x2305 => String::from("INVALID TOKEN OPERATION, TOKEN CORRUPT"),
            0x2306 => String::from("INVALID TOKEN OPERATION, TOKEN REVOKED"),
            0x2307 => String::from("INVALID TOKEN OPERATION, TOKEN EXPIRED"),
            0x2308 => String::from("INVALID TOKEN OPERATION, TOKEN CANCELLED"),
            0x2309 => String::from("INVALID TOKEN OPERATION, TOKEN DELETED"),
            0x230A => String::from("INVALID TOKEN OPERATION, INVALID TOKEN LENGTH"),
            0x2400 => String::from("INVALID FIELD IN CDB"),
            0x2401 => String::from("CDB DECRYPTION ERROR"),
            0x2402 => String::from("Obsolete"),
            0x2403 => String::from("Obsolete"),
            0x2404 => String::from("SECURITY AUDIT VALUE FROZEN"),
            0x2405 => String::from("SECURITY WORKING KEY FROZEN"),
            0x2406 => String::from("NONCE NOT UNIQUE"),
            0x2407 => String::from("NONCE TIMESTAMP OUT OF RANGE"),
            0x2408 => String::from("INVALID XCDB"),
            0x2409 => String::from("INVALID FAST FORMAT"),
            0x2500 => String::from("LOGICAL UNIT NOT SUPPORTED"),
            0x2600 => String::from("INVALID FIELD IN PARAMETER LIST"),
            0x2601 => String::from("PARAMETER NOT SUPPORTED"),
            0x2602 => String::from("PARAMETER VALUE INVALID"),
            0x2603 => String::from("THRESHOLD PARAMETERS NOT SUPPORTED"),
            0x2604 => String::from("INVALID RELEASE OF PERSISTENT RESERVATION"),
            0x2605 => String::from("DATA DECRYPTION ERROR"),
            0x2606 => String::from("TOO MANY TARGET DESCRIPTORS"),
            0x2607 => String::from("UNSUPPORTED TARGET DESCRIPTOR TYPE CODE"),
            0x2608 => String::from("TOO MANY SEGMENT DESCRIPTORS"),
            0x2609 => String::from("UNSUPPORTED SEGMENT DESCRIPTOR TYPE CODE"),
            0x260A => String::from("UNEXPECTED INEXACT SEGMENT"),
            0x260B => String::from("INLINE DATA LENGTH EXCEEDED"),
            0x260C => String::from("INVALID OPERATION FOR COPY SOURCE OR DESTINATION"),
            0x260D => String::from("COPY SEGMENT GRANULARITY VIOLATION"),
            0x260E => String::from("INVALID PARAMETER WHILE PORT IS ENABLED"),
            0x260F => String::from("INVALID DATA-OUT BUFFER INTEGRITY CHECK VALUE"),
            0x2610 => String::from("DATA DECRYPTION KEY FAIL LIMIT REACHED"),
            0x2611 => String::from("INCOMPLETE KEY-ASSOCIATED DATA SET"),
            0x2612 => String::from("VENDOR SPECIFIC KEY REFERENCE NOT FOUND"),
            0x2613 => String::from("APPLICATION TAG MODE PAGE IS INVALID"),
            0x2614 => String::from("TAPE STREAM MIRRORING PREVENTED"),
            0x2615 => String::from("COPY SOURCE OR COPY DESTINATION NOT AUTHORIZED"),
            0x2616 => String::from("FAST COPY NOT POSSIBLE"),
            0x2700 => String::from("WRITE PROTECTED"),
            0x2701 => String::from("HARDWARE WRITE PROTECTED"),
            0x2702 => String::from("LOGICAL UNIT SOFTWARE WRITE PROTECTED"),
            0x2703 => String::from("ASSOCIATED WRITE PROTECT"),
            0x2704 => String::from("PERSISTENT WRITE PROTECT"),
            0x2705 => String::from("PERMANENT WRITE PROTECT"),
            0x2706 => String::from("CONDITIONAL WRITE PROTECT"),
            0x2707 => String::from("SPACE ALLOCATION FAILED WRITE PROTECT"),
            0x2708 => String::from("ZONE IS READ ONLY"),
            0x2800 => String::from("NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED"),
            0x2801 => String::from("IMPORT OR EXPORT ELEMENT ACCESSED"),
            0x2802 => String::from("FORMAT-LAYER MAY HAVE CHANGED"),
            0x2803 => String::from("IMPORT/EXPORT ELEMENT ACCESSED, MEDIUM CHANGED"),
            0x2900 => String::from("POWER ON, RESET, OR BUS DEVICE RESET OCCURRED"),
            0x2901 => String::from("POWER ON OCCURRED"),
            0x2902 => String::from("SCSI BUS RESET OCCURRED"),
            0x2903 => String::from("BUS DEVICE RESET FUNCTION OCCURRED"),
            0x2904 => String::from("DEVICE INTERNAL RESET"),
            0x2905 => String::from("TRANSCEIVER MODE CHANGED TO SINGLE-ENDED"),
            0x2906 => String::from("TRANSCEIVER MODE CHANGED TO LVD"),
            0x2907 => String::from("I_T NEXUS LOSS OCCURRED"),
            0x2A00 => String::from("PARAMETERS CHANGED"),
            0x2A01 => String::from("MODE PARAMETERS CHANGED"),
            0x2A02 => String::from("LOG PARAMETERS CHANGED"),
            0x2A03 => String::from("RESERVATIONS PREEMPTED"),
            0x2A04 => String::from("RESERVATIONS RELEASED"),
            0x2A05 => String::from("REGISTRATIONS PREEMPTED"),
            0x2A06 => String::from("ASYMMETRIC ACCESS STATE CHANGED"),
            0x2A07 => String::from("IMPLICIT ASYMMETRIC ACCESS STATE TRANSITION FAILED"),
            0x2A08 => String::from("PRIORITY CHANGED"),
            0x2A09 => String::from("CAPACITY DATA HAS CHANGED"),
            0x2A0A => String::from("ERROR HISTORY I_T NEXUS CLEARED"),
            0x2A0B => String::from("ERROR HISTORY SNAPSHOT RELEASED"),
            0x2A0C => String::from("ERROR RECOVERY ATTRIBUTES HAVE CHANGED"),
            0x2A0D => String::from("DATA ENCRYPTION CAPABILITIES CHANGED"),
            0x2A10 => String::from("TIMESTAMP CHANGED"),
            0x2A11 => String::from("DATA ENCRYPTION PARAMETERS CHANGED BY ANOTHER I_T NEXUS"),
            0x2A12 => String::from("DATA ENCRYPTION PARAMETERS CHANGED BY VENDOR SPECIFIC EVENT"),
            0x2A13 => String::from("DATA ENCRYPTION KEY INSTANCE COUNTER HAS CHANGED"),
            0x2A14 => String::from("SA CREATION CAPABILITIES DATA HAS CHANGED"),
            0x2A15 => String::from("MEDIUM REMOVAL PREVENTION PREEMPTED"),
            0x2A16 => String::from("ZONE RESET WRITE POINTER RECOMMENDED"),
            0x2B00 => String::from("COPY CANNOT EXECUTE SINCE HOST CANNOT DISCONNECT"),
            0x2C00 => String::from("COMMAND SEQUENCE ERROR"),
            0x2C01 => String::from("TOO MANY WINDOWS SPECIFIED"),
            0x2C02 => String::from("INVALID COMBINATION OF WINDOWS SPECIFIED"),
            0x2C03 => String::from("CURRENT PROGRAM AREA IS NOT EMPTY"),
            0x2C04 => String::from("CURRENT PROGRAM AREA IS EMPTY"),
            0x2C05 => String::from("ILLEGAL POWER CONDITION REQUEST"),
            0x2C06 => String::from("PERSISTENT PREVENT CONFLICT"),
            0x2C07 => String::from("PREVIOUS BUSY STATUS"),
            0x2C08 => String::from("PREVIOUS TASK SET FULL STATUS"),
            0x2C09 => String::from("PREVIOUS RESERVATION CONFLICT STATUS"),
            0x2C0A => String::from("PARTITION OR COLLECTION CONTAINS USER OBJECTS"),
            0x2C0B => String::from("NOT RESERVED"),
            0x2C0C => String::from("ORWRITE GENERATION DOES NOT MATCH"),
            0x2C0D => String::from("RESET WRITE POINTER NOT ALLOWED"),
            0x2C0E => String::from("ZONE IS OFFLINE"),
            0x2C0F => String::from("STREAM NOT OPEN"),
            0x2C10 => String::from("UNWRITTEN DATA IN ZONE"),
            0x2C11 => String::from("DESCRIPTOR FORMAT SENSE DATA REQUIRED"),
            0x2C12 => String::from("ZONE IS INACTIVE"),
            0x2C13 => String::from("WELL KNOWN LOGICAL UNIT ACCESS REQUIRED"),
            0x2D00 => String::from("OVERWRITE ERROR ON UPDATE IN PLACE"),
            0x2E00 => String::from("INSUFFICIENT TIME FOR OPERATION"),
            0x2E01 => String::from("COMMAND TIMEOUT BEFORE PROCESSING"),
            0x2E02 => String::from("COMMAND TIMEOUT DURING PROCESSING"),
            0x2E03 => String::from("COMMAND TIMEOUT DURING PROCESSING DUE TO ERROR RECOVERY"),
            0x2F00 => String::from("COMMANDS CLEARED BY ANOTHER INITIATOR"),
            0x2F01 => String::from("COMMANDS CLEARED BY POWER LOSS NOTIFICATION"),
            0x2F02 => String::from("COMMANDS CLEARED BY DEVICE SERVER"),
            0x2F03 => String::from("SOME COMMANDS CLEARED BY QUEUING LAYER EVENT"),
            0x3000 => String::from("INCOMPATIBLE MEDIUM INSTALLED"),
            0x3001 => String::from("CANNOT READ MEDIUM - UNKNOWN FORMAT"),
            0x3002 => String::from("CANNOT READ MEDIUM - INCOMPATIBLE FORMAT"),
            0x3003 => String::from("CLEANING CARTRIDGE INSTALLED"),
            0x3004 => String::from("CANNOT WRITE MEDIUM - UNKNOWN FORMAT"),
            0x3005 => String::from("CANNOT WRITE MEDIUM - INCOMPATIBLE FORMAT"),
            0x3006 => String::from("CANNOT FORMAT MEDIUM - INCOMPATIBLE MEDIUM"),
            0x3007 => String::from("CLEANING FAILURE"),
            0x3008 => String::from("CANNOT WRITE - APPLICATION CODE MISMATCH"),
            0x3009 => String::from("CURRENT SESSION NOT FIXATED FOR APPEND"),
            0x300A => String::from("CLEANING REQUEST REJECTED"),
            0x300C => String::from("WORM MEDIUM - OVERWRITE ATTEMPTED"),
            0x300D => String::from("WORM MEDIUM - INTEGRITY CHECK"),
            0x3010 => String::from("MEDIUM NOT FORMATTED"),
            0x3011 => String::from("INCOMPATIBLE VOLUME TYPE"),
            0x3012 => String::from("INCOMPATIBLE VOLUME QUALIFIER"),
            0x3013 => String::from("CLEANING VOLUME EXPIRED"),
            0x3100 => String::from("MEDIUM FORMAT CORRUPTED"),
            0x3101 => String::from("FORMAT COMMAND FAILED"),
            0x3102 => String::from("ZONED FORMATTING FAILED DUE TO SPARE LINKING"),
            0x3103 => String::from("SANITIZE COMMAND FAILED"),
            0x3104 => String::from("DEPOPULATION FAILED"),
            0x3105 => String::from("DEPOPULATION RESTORATION FAILED"),
            0x3200 => String::from("NO DEFECT SPARE LOCATION AVAILABLE"),
            0x3201 => String::from("DEFECT LIST UPDATE FAILURE"),
            0x3300 => String::from("TAPE LENGTH ERROR"),
            0x3400 => String::from("ENCLOSURE FAILURE"),
            0x3500 => String::from("ENCLOSURE SERVICES FAILURE"),
            0x3501 => String::from("UNSUPPORTED ENCLOSURE FUNCTION"),
            0x3502 => String::from("ENCLOSURE SERVICES UNAVAILABLE"),
            0x3503 => String::from("ENCLOSURE SERVICES TRANSFER FAILURE"),
            0x3504 => String::from("ENCLOSURE SERVICES TRANSFER REFUSED"),
            0x3505 => String::from("ENCLOSURE SERVICES CHECKSUM ERROR"),
            0x3600 => String::from("RIBBON, INK, OR TONER FAILURE"),
            0x3700 => String::from("ROUNDED PARAMETER"),
            0x3800 => String::from("EVENT STATUS NOTIFICATION"),
            0x3802 => String::from("ESN - POWER MANAGEMENT CLASS EVENT"),
            0x3804 => String::from("ESN - MEDIA CLASS EVENT"),
            0x3806 => String::from("ESN - DEVICE BUSY CLASS EVENT"),
            0x3807 => String::from("THIN PROVISIONING SOFT THRESHOLD REACHED"),
            0x3808 => String::from("DEPOPULATION INTERRUPTED"),
            0x3900 => String::from("SAVING PARAMETERS NOT SUPPORTED"),
            0x3A00 => String::from("MEDIUM NOT PRESENT"),
            0x3A01 => String::from("MEDIUM NOT PRESENT - TRAY CLOSED"),
            0x3A02 => String::from("MEDIUM NOT PRESENT - TRAY OPEN"),
            0x3A03 => String::from("MEDIUM NOT PRESENT - LOADABLE"),
            0x3A04 => String::from("MEDIUM NOT PRESENT - MEDIUM AUXILIARY MEMORY ACCESSIBLE"),
            0x3B00 => String::from("SEQUENTIAL POSITIONING ERROR"),
            0x3B01 => String::from("TAPE POSITION ERROR AT BEGINNING-OF-MEDIUM"),
            0x3B02 => String::from("TAPE POSITION ERROR AT END-OF-MEDIUM"),
            0x3B03 => String::from("TAPE OR ELECTRONIC VERTICAL FORMS UNIT NOT READY"),
            0x3B04 => String::from("SLEW FAILURE"),
            0x3B05 => String::from("PAPER JAM"),
            0x3B06 => String::from("FAILED TO SENSE TOP-OF-FORM"),
            0x3B07 => String::from("FAILED TO SENSE BOTTOM-OF-FORM"),
            0x3B08 => String::from("REPOSITION ERROR"),
            0x3B09 => String::from("READ PAST END OF MEDIUM"),
            0x3B0A => String::from("READ PAST BEGINNING OF MEDIUM"),
            0x3B0B => String::from("POSITION PAST END OF MEDIUM"),
            0x3B0C => String::from("POSITION PAST BEGINNING OF MEDIUM"),
            0x3B0D => String::from("MEDIUM DESTINATION ELEMENT FULL"),
            0x3B0E => String::from("MEDIUM SOURCE ELEMENT EMPTY"),
            0x3B0F => String::from("END OF MEDIUM REACHED"),
            0x3B11 => String::from("MEDIUM MAGAZINE NOT ACCESSIBLE"),
            0x3B12 => String::from("MEDIUM MAGAZINE REMOVED"),
            0x3B13 => String::from("MEDIUM MAGAZINE INSERTED"),
            0x3B14 => String::from("MEDIUM MAGAZINE LOCKED"),
            0x3B15 => String::from("MEDIUM MAGAZINE UNLOCKED"),
            0x3B16 => String::from("MECHANICAL POSITIONING OR CHANGER ERROR"),
            0x3B17 => String::from("READ PAST END OF USER OBJECT"),
            0x3B18 => String::from("ELEMENT DISABLED"),
            0x3B19 => String::from("ELEMENT ENABLED"),
            0x3B1A => String::from("DATA TRANSFER DEVICE REMOVED"),
            0x3B1B => String::from("DATA TRANSFER DEVICE INSERTED"),
            0x3B1C => String::from("TOO MANY LOGICAL OBJECTS ON PARTITION TO SUPPORT OPERATION"),
            0x3B20 => String::from("ELEMENT STATIC INFORMATION CHANGED"),
            0x3D00 => String::from("INVALID BITS IN IDENTIFY MESSAGE"),
            0x3E00 => String::from("LOGICAL UNIT HAS NOT SELF-CONFIGURED YET"),
            0x3E01 => String::from("LOGICAL UNIT FAILURE"),
            0x3E02 => String::from("TIMEOUT ON LOGICAL UNIT"),
            0x3E03 => String::from("LOGICAL UNIT FAILED SELF-TEST"),
            0x3E04 => String::from("LOGICAL UNIT UNABLE TO UPDATE SELF-TEST LOG"),
            0x3F00 => String::from("TARGET OPERATING CONDITIONS HAVE CHANGED"),
            0x3F01 => String::from("MICROCODE HAS BEEN CHANGED"),
            0x3F02 => String::from("CHANGED OPERATING DEFINITION"),
            0x3F03 => String::from("INQUIRY DATA HAS CHANGED"),
            0x3F04 => String::from("COMPONENT DEVICE ATTACHED"),
            0x3F05 => String::from("DEVICE IDENTIFIER CHANGED"),
            0x3F06 => String::from("REDUNDANCY GROUP CREATED OR MODIFIED"),
            0x3F07 => String::from("REDUNDANCY GROUP DELETED"),
            0x3F08 => String::from("SPARE CREATED OR MODIFIED"),
            0x3F09 => String::from("SPARE DELETED"),
            0x3F0A => String::from("VOLUME SET CREATED OR MODIFIED"),
            0x3F0B => String::from("VOLUME SET DELETED"),
            0x3F0C => String::from("VOLUME SET DEASSIGNED"),
            0x3F0D => String::from("VOLUME SET REASSIGNED"),
            0x3F0E => String::from("REPORTED LUNS DATA HAS CHANGED"),
            0x3F0F => String::from("ECHO BUFFER OVERWRITTEN"),
            0x3F10 => String::from("MEDIUM LOADABLE"),
            0x3F11 => String::from("MEDIUM AUXILIARY MEMORY ACCESSIBLE"),
            0x3F12 => String::from("iSCSI IP ADDRESS ADDED"),
            0x3F13 => String::from("iSCSI IP ADDRESS REMOVED"),
            0x3F14 => String::from("iSCSI IP ADDRESS CHANGED"),
            0x3F15 => String::from("INSPECT REFERRALS SENSE DESCRIPTORS"),
            0x3F16 => String::from("MICROCODE HAS BEEN CHANGED WITHOUT RESET"),
            0x3F17 => String::from("ZONE TRANSITION TO FULL"),
            0x3F18 => String::from("BIND COMPLETED"),
            0x3F19 => String::from("BIND REDIRECTED"),
            0x3F1A => String::from("SUBSIDIARY BINDING CHANGED"),
            0x4000 => String::from("RAM FAILURE (SHOULD USE 40 NN)"),
            0x4100 => String::from("DATA PATH FAILURE (SHOULD USE 40 NN)"),
            0x4200 => String::from("POWER-ON OR SELF-TEST FAILURE (SHOULD USE 40 NN)"),
            0x4300 => String::from("MESSAGE ERROR"),
            0x4400 => String::from("INTERNAL TARGET FAILURE"),
            0x4401 => String::from("PERSISTENT RESERVATION INFORMATION LOST"),
            0x4471 => String::from("ATA DEVICE FAILED SET FEATURES"),
            0x4500 => String::from("SELECT OR RESELECT FAILURE"),
            0x4600 => String::from("UNSUCCESSFUL SOFT RESET"),
            0x4700 => String::from("SCSI PARITY ERROR"),
            0x4701 => String::from("DATA PHASE CRC ERROR DETECTED"),
            0x4702 => String::from("SCSI PARITY ERROR DETECTED DURING ST DATA PHASE"),
            0x4703 => String::from("INFORMATION UNIT iuCRC ERROR DETECTED"),
            0x4704 => String::from("ASYNCHRONOUS INFORMATION PROTECTION ERROR DETECTED"),
            0x4705 => String::from("PROTOCOL SERVICE CRC ERROR"),
            0x4706 => String::from("PHY TEST FUNCTION IN PROGRESS"),
            0x477F => String::from("SOME COMMANDS CLEARED BY ISCSI PROTOCOL EVENT"),
            0x4800 => String::from("INITIATOR DETECTED ERROR MESSAGE RECEIVED"),
            0x4900 => String::from("INVALID MESSAGE ERROR"),
            0x4A00 => String::from("COMMAND PHASE ERROR"),
            0x4B00 => String::from("DATA PHASE ERROR"),
            0x4B01 => String::from("INVALID TARGET PORT TRANSFER TAG RECEIVED"),
            0x4B02 => String::from("TOO MUCH WRITE DATA"),
            0x4B03 => String::from("ACK/NAK TIMEOUT"),
            0x4B04 => String::from("NAK RECEIVED"),
            0x4B05 => String::from("DATA OFFSET ERROR"),
            0x4B06 => String::from("INITIATOR RESPONSE TIMEOUT"),
            0x4B07 => String::from("CONNECTION LOST"),
            0x4B08 => String::from("DATA-IN BUFFER OVERFLOW - DATA BUFFER SIZE"),
            0x4B09 => String::from("DATA-IN BUFFER OVERFLOW - DATA BUFFER DESCRIPTOR AREA"),
            0x4B0A => String::from("DATA-IN BUFFER ERROR"),
            0x4B0B => String::from("DATA-OUT BUFFER OVERFLOW - DATA BUFFER SIZE"),
            0x4B0C => String::from("DATA-OUT BUFFER OVERFLOW - DATA BUFFER DESCRIPTOR AREA"),
            0x4B0D => String::from("DATA-OUT BUFFER ERROR"),
            0x4B0E => String::from("PCIE FABRIC ERROR"),
            0x4B0F => String::from("PCIE COMPLETION TIMEOUT"),
            0x4B10 => String::from("PCIE COMPLETER ABORT"),
            0x4B11 => String::from("PCIE POISONED TLP RECEIVED"),
            0x4B12 => String::from("PCIE ECRC CHECK FAILED"),
            0x4B13 => String::from("PCIE UNSUPPORTED REQUEST"),
            0x4B14 => String::from("PCIE ACS VIOLATION"),
            0x4B15 => String::from("PCIE TLP PREFIX BLOCKED"),
            0x4C00 => String::from("LOGICAL UNIT FAILED SELF-CONFIGURATION"),
            0x4E00 => String::from("OVERLAPPED COMMANDS ATTEMPTED"),
            0x5000 => String::from("WRITE APPEND ERROR"),
            0x5001 => String::from("WRITE APPEND POSITION ERROR"),
            0x5002 => String::from("POSITION ERROR RELATED TO TIMING"),
            0x5100 => String::from("ERASE FAILURE"),
            0x5101 => String::from("ERASE FAILURE - INCOMPLETE ERASE OPERATION DETECTED"),
            0x5200 => String::from("CARTRIDGE FAULT"),
            0x5300 => String::from("MEDIA LOAD OR EJECT FAILED"),
            0x5301 => String::from("UNLOAD TAPE FAILURE"),
            0x5302 => String::from("MEDIUM REMOVAL PREVENTED"),
            0x5303 => String::from("MEDIUM REMOVAL PREVENTED BY DATA TRANSFER ELEMENT"),
            0x5304 => String::from("MEDIUM THREAD OR UNTHREAD FAILURE"),
            0x5305 => String::from("VOLUME IDENTIFIER INVALID"),
            0x5306 => String::from("VOLUME IDENTIFIER MISSING"),
            0x5307 => String::from("DUPLICATE VOLUME IDENTIFIER"),
            0x5308 => String::from("ELEMENT STATUS UNKNOWN"),
            0x5309 => String::from("DATA TRANSFER DEVICE ERROR - LOAD FAILED"),
            0x530A => String::from("DATA TRANSFER DEVICE ERROR - UNLOAD FAILED"),
            0x530B => String::from("DATA TRANSFER DEVICE ERROR - UNLOAD MISSING"),
            0x530C => String::from("DATA TRANSFER DEVICE ERROR - EJECT FAILED"),
            0x530D => String::from("DATA TRANSFER DEVICE ERROR - LIBRARY COMMUNICATION FAILED"),
            0x5400 => String::from("SCSI TO HOST SYSTEM INTERFACE FAILURE"),
            0x5500 => String::from("SYSTEM RESOURCE FAILURE"),
            0x5501 => String::from("SYSTEM BUFFER FULL"),
            0x5502 => String::from("INSUFFICIENT RESERVATION RESOURCES"),
            0x5503 => String::from("INSUFFICIENT RESOURCES"),
            0x5504 => String::from("INSUFFICIENT REGISTRATION RESOURCES"),
            0x5505 => String::from("INSUFFICIENT ACCESS CONTROL RESOURCES"),
            0x5506 => String::from("AUXILIARY MEMORY OUT OF SPACE"),
            0x5507 => String::from("QUOTA ERROR"),
            0x5508 => String::from("MAXIMUM NUMBER OF SUPPLEMENTAL DECRYPTION KEYS EXCEEDED"),
            0x5509 => String::from("MEDIUM AUXILIARY MEMORY NOT ACCESSIBLE"),
            0x550A => String::from("DATA CURRENTLY UNAVAILABLE"),
            0x550B => String::from("INSUFFICIENT POWER FOR OPERATION"),
            0x550C => String::from("INSUFFICIENT RESOURCES TO CREATE ROD"),
            0x550D => String::from("INSUFFICIENT RESOURCES TO CREATE ROD TOKEN"),
            0x550E => String::from("INSUFFICIENT ZONE RESOURCES"),
            0x550F => String::from("INSUFFICIENT ZONE RESOURCES TO COMPLETE WRITE"),
            0x5510 => String::from("MAXIMUM NUMBER OF STREAMS OPEN"),
            0x5511 => String::from("INSUFFICIENT RESOURCES TO BIND"),
            0x5700 => String::from("UNABLE TO RECOVER TABLE-OF-CONTENTS"),
            0x5800 => String::from("GENERATION DOES NOT EXIST"),
            0x5900 => String::from("UPDATED BLOCK READ"),
            0x5A00 => String::from("OPERATOR REQUEST OR STATE CHANGE INPUT"),
            0x5A01 => String::from("OPERATOR MEDIUM REMOVAL REQUEST"),
            0x5A02 => String::from("OPERATOR SELECTED WRITE PROTECT"),
            0x5A03 => String::from("OPERATOR SELECTED WRITE PERMIT"),
            0x5B00 => String::from("LOG EXCEPTION"),
            0x5B01 => String::from("THRESHOLD CONDITION MET"),
            0x5B02 => String::from("LOG COUNTER AT MAXIMUM"),
            0x5B03 => String::from("LOG LIST CODES EXHAUSTED"),
            0x5C00 => String::from("RPL STATUS CHANGE"),
            0x5C01 => String::from("SPINDLES SYNCHRONIZED"),
            0x5C02 => String::from("SPINDLES NOT SYNCHRONIZED"),
            0x5D00 => String::from("FAILURE PREDICTION THRESHOLD EXCEEDED"),
            0x5D01 => String::from("MEDIA FAILURE PREDICTION THRESHOLD EXCEEDED"),
            0x5D02 => String::from("LOGICAL UNIT FAILURE PREDICTION THRESHOLD EXCEEDED"),
            0x5D03 => String::from("SPARE AREA EXHAUSTION PREDICTION THRESHOLD EXCEEDED"),
            0x5D10 => String::from("HARDWARE IMPENDING FAILURE GENERAL HARD DRIVE FAILURE"),
            0x5D11 => String::from("HARDWARE IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH"),
            0x5D12 => String::from("HARDWARE IMPENDING FAILURE DATA ERROR RATE TOO HIGH"),
            0x5D13 => String::from("HARDWARE IMPENDING FAILURE SEEK ERROR RATE TOO HIGH"),
            0x5D14 => String::from("HARDWARE IMPENDING FAILURE TOO MANY BLOCK REASSIGNS"),
            0x5D15 => String::from("HARDWARE IMPENDING FAILURE ACCESS TIMES TOO HIGH"),
            0x5D16 => String::from("HARDWARE IMPENDING FAILURE START UNIT TIMES TOO HIGH"),
            0x5D17 => String::from("HARDWARE IMPENDING FAILURE CHANNEL PARAMETRICS"),
            0x5D18 => String::from("HARDWARE IMPENDING FAILURE CONTROLLER DETECTED"),
            0x5D19 => String::from("HARDWARE IMPENDING FAILURE THROUGHPUT PERFORMANCE"),
            0x5D1A => String::from("HARDWARE IMPENDING FAILURE SEEK TIME PERFORMANCE"),
            0x5D1B => String::from("HARDWARE IMPENDING FAILURE SPIN-UP RETRY COUNT"),
            0x5D1C => String::from("HARDWARE IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT"),
            0x5D1D => String::from("HARDWARE IMPENDING FAILURE POWER LOSS PROTECTION CIRCUIT"),
            0x5D20 => String::from("CONTROLLER IMPENDING FAILURE GENERAL HARD DRIVE FAILURE"),
            0x5D21 => String::from("CONTROLLER IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH"),
            0x5D22 => String::from("CONTROLLER IMPENDING FAILURE DATA ERROR RATE TOO HIGH"),
            0x5D23 => String::from("CONTROLLER IMPENDING FAILURE SEEK ERROR RATE TOO HIGH"),
            0x5D24 => String::from("CONTROLLER IMPENDING FAILURE TOO MANY BLOCK REASSIGNS"),
            0x5D25 => String::from("CONTROLLER IMPENDING FAILURE ACCESS TIMES TOO HIGH"),
            0x5D26 => String::from("CONTROLLER IMPENDING FAILURE START UNIT TIMES TOO HIGH"),
            0x5D27 => String::from("CONTROLLER IMPENDING FAILURE CHANNEL PARAMETRICS"),
            0x5D28 => String::from("CONTROLLER IMPENDING FAILURE CONTROLLER DETECTED"),
            0x5D29 => String::from("CONTROLLER IMPENDING FAILURE THROUGHPUT PERFORMANCE"),
            0x5D2A => String::from("CONTROLLER IMPENDING FAILURE SEEK TIME PERFORMANCE"),
            0x5D2B => String::from("CONTROLLER IMPENDING FAILURE SPIN-UP RETRY COUNT"),
            0x5D2C => String::from("CONTROLLER IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT"),
            0x5D30 => String::from("DATA CHANNEL IMPENDING FAILURE GENERAL HARD DRIVE FAILURE"),
            0x5D31 => String::from("DATA CHANNEL IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH"),
            0x5D32 => String::from("DATA CHANNEL IMPENDING FAILURE DATA ERROR RATE TOO HIGH"),
            0x5D33 => String::from("DATA CHANNEL IMPENDING FAILURE SEEK ERROR RATE TOO HIGH"),
            0x5D34 => String::from("DATA CHANNEL IMPENDING FAILURE TOO MANY BLOCK REASSIGNS"),
            0x5D35 => String::from("DATA CHANNEL IMPENDING FAILURE ACCESS TIMES TOO HIGH"),
            0x5D36 => String::from("DATA CHANNEL IMPENDING FAILURE START UNIT TIMES TOO HIGH"),
            0x5D37 => String::from("DATA CHANNEL IMPENDING FAILURE CHANNEL PARAMETRICS"),
            0x5D38 => String::from("DATA CHANNEL IMPENDING FAILURE CONTROLLER DETECTED"),
            0x5D39 => String::from("DATA CHANNEL IMPENDING FAILURE THROUGHPUT PERFORMANCE"),
            0x5D3A => String::from("DATA CHANNEL IMPENDING FAILURE SEEK TIME PERFORMANCE"),
            0x5D3B => String::from("DATA CHANNEL IMPENDING FAILURE SPIN-UP RETRY COUNT"),
            0x5D3C => String::from("DATA CHANNEL IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT"),
            0x5D40 => String::from("SERVO IMPENDING FAILURE GENERAL HARD DRIVE FAILURE"),
            0x5D41 => String::from("SERVO IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH"),
            0x5D42 => String::from("SERVO IMPENDING FAILURE DATA ERROR RATE TOO HIGH"),
            0x5D43 => String::from("SERVO IMPENDING FAILURE SEEK ERROR RATE TOO HIGH"),
            0x5D44 => String::from("SERVO IMPENDING FAILURE TOO MANY BLOCK REASSIGNS"),
            0x5D45 => String::from("SERVO IMPENDING FAILURE ACCESS TIMES TOO HIGH"),
            0x5D46 => String::from("SERVO IMPENDING FAILURE START UNIT TIMES TOO HIGH"),
            0x5D47 => String::from("SERVO IMPENDING FAILURE CHANNEL PARAMETRICS"),
            0x5D48 => String::from("SERVO IMPENDING FAILURE CONTROLLER DETECTED"),
            0x5D49 => String::from("SERVO IMPENDING FAILURE THROUGHPUT PERFORMANCE"),
            0x5D4A => String::from("SERVO IMPENDING FAILURE SEEK TIME PERFORMANCE"),
            0x5D4B => String::from("SERVO IMPENDING FAILURE SPIN-UP RETRY COUNT"),
            0x5D4C => String::from("SERVO IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT"),
            0x5D50 => String::from("SPINDLE IMPENDING FAILURE GENERAL HARD DRIVE FAILURE"),
            0x5D51 => String::from("SPINDLE IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH"),
            0x5D52 => String::from("SPINDLE IMPENDING FAILURE DATA ERROR RATE TOO HIGH"),
            0x5D53 => String::from("SPINDLE IMPENDING FAILURE SEEK ERROR RATE TOO HIGH"),
            0x5D54 => String::from("SPINDLE IMPENDING FAILURE TOO MANY BLOCK REASSIGNS"),
            0x5D55 => String::from("SPINDLE IMPENDING FAILURE ACCESS TIMES TOO HIGH"),
            0x5D56 => String::from("SPINDLE IMPENDING FAILURE START UNIT TIMES TOO HIGH"),
            0x5D57 => String::from("SPINDLE IMPENDING FAILURE CHANNEL PARAMETRICS"),
            0x5D58 => String::from("SPINDLE IMPENDING FAILURE CONTROLLER DETECTED"),
            0x5D59 => String::from("SPINDLE IMPENDING FAILURE THROUGHPUT PERFORMANCE"),
            0x5D5A => String::from("SPINDLE IMPENDING FAILURE SEEK TIME PERFORMANCE"),
            0x5D5B => String::from("SPINDLE IMPENDING FAILURE SPIN-UP RETRY COUNT"),
            0x5D5C => String::from("SPINDLE IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT"),
            0x5D60 => String::from("FIRMWARE IMPENDING FAILURE GENERAL HARD DRIVE FAILURE"),
            0x5D61 => String::from("FIRMWARE IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH"),
            0x5D62 => String::from("FIRMWARE IMPENDING FAILURE DATA ERROR RATE TOO HIGH"),
            0x5D63 => String::from("FIRMWARE IMPENDING FAILURE SEEK ERROR RATE TOO HIGH"),
            0x5D64 => String::from("FIRMWARE IMPENDING FAILURE TOO MANY BLOCK REASSIGNS"),
            0x5D65 => String::from("FIRMWARE IMPENDING FAILURE ACCESS TIMES TOO HIGH"),
            0x5D66 => String::from("FIRMWARE IMPENDING FAILURE START UNIT TIMES TOO HIGH"),
            0x5D67 => String::from("FIRMWARE IMPENDING FAILURE CHANNEL PARAMETRICS"),
            0x5D68 => String::from("FIRMWARE IMPENDING FAILURE CONTROLLER DETECTED"),
            0x5D69 => String::from("FIRMWARE IMPENDING FAILURE THROUGHPUT PERFORMANCE"),
            0x5D6A => String::from("FIRMWARE IMPENDING FAILURE SEEK TIME PERFORMANCE"),
            0x5D6B => String::from("FIRMWARE IMPENDING FAILURE SPIN-UP RETRY COUNT"),
            0x5D6C => String::from("FIRMWARE IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT"),
            0x5D73 => String::from("MEDIA IMPENDING FAILURE ENDURANCE LIMIT MET"),
            0x5DFF => String::from("FAILURE PREDICTION THRESHOLD EXCEEDED (FALSE)"),
            0x5E00 => String::from("LOW POWER CONDITION ON"),
            0x5E01 => String::from("IDLE CONDITION ACTIVATED BY TIMER"),
            0x5E02 => String::from("STANDBY CONDITION ACTIVATED BY TIMER"),
            0x5E03 => String::from("IDLE CONDITION ACTIVATED BY COMMAND"),
            0x5E04 => String::from("STANDBY CONDITION ACTIVATED BY COMMAND"),
            0x5E05 => String::from("IDLE_B CONDITION ACTIVATED BY TIMER"),
            0x5E06 => String::from("IDLE_B CONDITION ACTIVATED BY COMMAND"),
            0x5E07 => String::from("IDLE_C CONDITION ACTIVATED BY TIMER"),
            0x5E08 => String::from("IDLE_C CONDITION ACTIVATED BY COMMAND"),
            0x5E09 => String::from("STANDBY_Y CONDITION ACTIVATED BY TIMER"),
            0x5E0A => String::from("STANDBY_Y CONDITION ACTIVATED BY COMMAND"),
            0x5E41 => String::from("POWER STATE CHANGE TO ACTIVE"),
            0x5E42 => String::from("POWER STATE CHANGE TO IDLE"),
            0x5E43 => String::from("POWER STATE CHANGE TO STANDBY"),
            0x5E45 => String::from("POWER STATE CHANGE TO SLEEP"),
            0x5E47 => String::from("POWER STATE CHANGE TO DEVICE CONTROL"),
            0x6000 => String::from("LAMP FAILURE"),
            0x6100 => String::from("VIDEO ACQUISITION ERROR"),
            0x6101 => String::from("UNABLE TO ACQUIRE VIDEO"),
            0x6102 => String::from("OUT OF FOCUS"),
            0x6200 => String::from("SCAN HEAD POSITIONING ERROR"),
            0x6300 => String::from("END OF USER AREA ENCOUNTERED ON THIS TRACK"),
            0x6301 => String::from("PACKET DOES NOT FIT IN AVAILABLE SPACE"),
            0x6400 => String::from("ILLEGAL MODE FOR THIS TRACK"),
            0x6401 => String::from("INVALID PACKET SIZE"),
            0x6500 => String::from("VOLTAGE FAULT"),
            0x6600 => String::from("AUTOMATIC DOCUMENT FEEDER COVER UP"),
            0x6601 => String::from("AUTOMATIC DOCUMENT FEEDER LIFT UP"),
            0x6602 => String::from("DOCUMENT JAM IN AUTOMATIC DOCUMENT FEEDER"),
            0x6603 => String::from("DOCUMENT MISS FEED AUTOMATIC IN DOCUMENT FEEDER"),
            0x6700 => String::from("CONFIGURATION FAILURE"),
            0x6701 => String::from("CONFIGURATION OF INCAPABLE LOGICAL UNITS FAILED"),
            0x6702 => String::from("ADD LOGICAL UNIT FAILED"),
            0x6703 => String::from("MODIFICATION OF LOGICAL UNIT FAILED"),
            0x6704 => String::from("EXCHANGE OF LOGICAL UNIT FAILED"),
            0x6705 => String::from("REMOVE OF LOGICAL UNIT FAILED"),
            0x6706 => String::from("ATTACHMENT OF LOGICAL UNIT FAILED"),
            0x6707 => String::from("CREATION OF LOGICAL UNIT FAILED"),
            0x6708 => String::from("ASSIGN FAILURE OCCURRED"),
            0x6709 => String::from("MULTIPLY ASSIGNED LOGICAL UNIT"),
            0x670A => String::from("SET TARGET PORT GROUPS COMMAND FAILED"),
            0x670B => String::from("ATA DEVICE FEATURE NOT ENABLED"),
            0x670C => String::from("COMMAND REJECTED"),
            0x670D => String::from("EXPLICIT BIND NOT ALLOWED"),
            0x6800 => String::from("LOGICAL UNIT NOT CONFIGURED"),
            0x6801 => String::from("SUBSIDIARY LOGICAL UNIT NOT CONFIGURED"),
            0x6900 => String::from("DATA LOSS ON LOGICAL UNIT"),
            0x6901 => String::from("MULTIPLE LOGICAL UNIT FAILURES"),
            0x6902 => String::from("PARITY/DATA MISMATCH"),
            0x6A00 => String::from("INFORMATIONAL, REFER TO LOG"),
            0x6B00 => String::from("STATE CHANGE HAS OCCURRED"),
            0x6B01 => String::from("REDUNDANCY LEVEL GOT BETTER"),
            0x6B02 => String::from("REDUNDANCY LEVEL GOT WORSE"),
            0x6C00 => String::from("REBUILD FAILURE OCCURRED"),
            0x6D00 => String::from("RECALCULATE FAILURE OCCURRED"),
            0x6E00 => String::from("COMMAND TO LOGICAL UNIT FAILED"),
            0x6F00 => String::from("COPY PROTECTION KEY EXCHANGE FAILURE - AUTHENTICATION FAILURE"),
            0x6F01 => String::from("COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT PRESENT"),
            0x6F02 => String::from("COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT ESTABLISHED"),
            0x6F03 => String::from("READ OF SCRAMBLED SECTOR WITHOUT AUTHENTICATION"),
            0x6F04 => String::from("MEDIA REGION CODE IS MISMATCHED TO LOGICAL UNIT REGION"),
            0x6F05 => String::from("DRIVE REGION MUST BE PERMANENT/REGION RESET COUNT ERROR"),
            0x6F06 => String::from("INSUFFICIENT BLOCK COUNT FOR BINDING NONCE RECORDING"),
            0x6F07 => String::from("CONFLICT IN BINDING NONCE RECORDING"),
            0x6F08 => String::from("INSUFFICIENT PERMISSION"),
            0x6F09 => String::from("INVALID DRIVE-HOST PAIRING SERVER"),
            0x6F0A => String::from("DRIVE-HOST PAIRING SUSPENDED"),
            0x7100 => String::from("DECOMPRESSION EXCEPTION LONG ALGORITHM ID"),
            0x7200 => String::from("SESSION FIXATION ERROR"),
            0x7201 => String::from("SESSION FIXATION ERROR WRITING LEAD-IN"),
            0x7202 => String::from("SESSION FIXATION ERROR WRITING LEAD-OUT"),
            0x7203 => String::from("SESSION FIXATION ERROR - INCOMPLETE TRACK IN SESSION"),
            0x7204 => String::from("EMPTY OR PARTIALLY WRITTEN RESERVED TRACK"),
            0x7205 => String::from("NO MORE TRACK RESERVATIONS ALLOWED"),
            0x7206 => String::from("RMZ EXTENSION IS NOT ALLOWED"),
            0x7207 => String::from("NO MORE TEST ZONE EXTENSIONS ARE ALLOWED"),
            0x7300 => String::from("CD CONTROL ERROR"),
            0x7301 => String::from("POWER CALIBRATION AREA ALMOST FULL"),
            0x7302 => String::from("POWER CALIBRATION AREA IS FULL"),
            0x7303 => String::from("POWER CALIBRATION AREA ERROR"),
            0x7304 => String::from("PROGRAM MEMORY AREA UPDATE FAILURE"),
            0x7305 => String::from("PROGRAM MEMORY AREA IS FULL"),
            0x7306 => String::from("RMA/PMA IS ALMOST FULL"),
            0x7310 => String::from("CURRENT POWER CALIBRATION AREA ALMOST FULL"),
            0x7311 => String::from("CURRENT POWER CALIBRATION AREA IS FULL"),
            0x7317 => String::from("RDZ IS FULL"),
            0x7400 => String::from("SECURITY ERROR"),
            0x7401 => String::from("UNABLE TO DECRYPT DATA"),
            0x7402 => String::from("UNENCRYPTED DATA ENCOUNTERED WHILE DECRYPTING"),
            0x7403 => String::from("INCORRECT DATA ENCRYPTION KEY"),
            0x7404 => String::from("CRYPTOGRAPHIC INTEGRITY VALIDATION FAILED"),
            0x7405 => String::from("ERROR DECRYPTING DATA"),
            0x7406 => String::from("UNKNOWN SIGNATURE VERIFICATION KEY"),
            0x7407 => String::from("ENCRYPTION PARAMETERS NOT USEABLE"),
            0x7408 => String::from("DIGITAL SIGNATURE VALIDATION FAILURE"),
            0x7409 => String::from("ENCRYPTION MODE MISMATCH ON READ"),
            0x740A => String::from("ENCRYPTED BLOCK NOT RAW READ ENABLED"),
            0x740B => String::from("INCORRECT ENCRYPTION PARAMETERS"),
            0x740C => String::from("UNABLE TO DECRYPT PARAMETER LIST"),
            0x740D => String::from("ENCRYPTION ALGORITHM DISABLED"),
            0x7410 => String::from("SA CREATION PARAMETER VALUE INVALID"),
            0x7411 => String::from("SA CREATION PARAMETER VALUE REJECTED"),
            0x7412 => String::from("INVALID SA USAGE"),
            0x7421 => String::from("DATA ENCRYPTION CONFIGURATION PREVENTED"),
            0x7430 => String::from("SA CREATION PARAMETER NOT SUPPORTED"),
            0x7440 => String::from("AUTHENTICATION FAILED"),
            0x7461 => String::from("EXTERNAL DATA ENCRYPTION KEY MANAGER ACCESS ERROR"),
            0x7462 => String::from("EXTERNAL DATA ENCRYPTION KEY MANAGER ERROR"),
            0x7463 => String::from("EXTERNAL DATA ENCRYPTION KEY NOT FOUND"),
            0x7464 => String::from("EXTERNAL DATA ENCRYPTION REQUEST NOT AUTHORIZED"),
            0x746E => String::from("EXTERNAL DATA ENCRYPTION CONTROL TIMEOUT"),
            0x746F => String::from("EXTERNAL DATA ENCRYPTION CONTROL ERROR"),
            0x7471 => String::from("LOGICAL UNIT ACCESS NOT AUTHORIZED"),
            0x7479 => String::from("SECURITY CONFLICT IN TRANSLATED DEVICE"),
            other => {
                let [asc, ascq] = other.to_be_bytes();
                match asc {
                    0x40 => format!("DIAGNOSTIC FAILURE ON COMPONENT 0x{:X}", ascq),
                    0x4D => format!("TAGGED OVERLAPPED COMMANDS ON TASK TAG 0x{:X}", ascq),
                    0x70 => format!("DECOMPRESSION EXCEPTION SHORT ALGORITHM ID OF 0x{:X}", ascq),
                    _ => format!("Unknown Code 0x{:X}", other),
                }
            }
        };
        write!(f, "({:X}) {}", self.0, &description)
    }
}

impl Debug for AdditionalSenseCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

impl From<(u8, u8)> for AdditionalSenseCode {
    fn from(value: (u8, u8)) -> Self {
        let value = ((value.0 as u16) << 8) + value.1 as u16;
        AdditionalSenseCode(value)
    }
}

impl From<AdditionalSenseCode> for (u8, u8) {
    fn from(value: AdditionalSenseCode) -> Self {
        let [asc, ascq] = value.0.to_be_bytes();
        (asc, ascq)
    }
}

const DESCRIPTOR_HEADER_LENGTH: usize = 2;
